}
Y<- sapply(1:length(dados),FUN=function(x)ewma.r(x=dados[1:x], lambda=peso,mi0=alvo))
#Y[length(Y)] <- peso*dados[length(dados)] + (1-peso)*Y[length(dados)]
#primeira versao
Y<-0
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==1) return(mi0)
return(lambda*x[i-1] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
for(i in 1:length(dados)){
Y[i]<-ewma.r(dados[1:i],peso,alvo)
}
Y<- sapply(1:length(dados),FUN=function(x)ewma.r(x=dados[1:x], lambda=peso,mi0=alvo))
#Y[length(Y)] <- peso*dados[length(dados)] + (1-peso)*Y[length(dados)]
Y
#primeira versao
Y<-0
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
Y<- sapply(1:length(dados),FUN=function(x)ewma.r(x=dados[1:x], lambda=peso,mi0=alvo))
#Y[length(Y)] <- peso*dados[length(dados)] + (1-peso)*Y[length(dados)]
Y
medias.ew
#primeira versao
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=alvo)
})
)
Y
#primeira versao
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=Y)
})
)
Y
dados<-as.vector(read.table("Tab7.1-Costa.txt",dec=","))[[1]]
alvo<- 100
peso<- 0.2
medias.ew<-ewma(dados, lambda=peso,mi0=alvo)
dados
plot(medias.ew, type="o",pch=19,xlab="Amostra")
medias.ew == Y
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=Y)
})
)
all.equal(medias.ew,Y)
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
#aplica a função para cada posição
Y<- sapply(1:length(dados), FUN=function(x)ewma.r(x=dados[0:x], lambda=peso,mi0=Y) )
#verifica se produz a mesma saída
all.equal(medias.ew,Y)
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
#aplica a função para cada posição
Y<- sapply(1:length(dados), FUN=function(x)ewma.r(x=dados[0:x], lambda=peso,mi0=Y) )
#verifica se produz a mesma saída
#all.equal(medias.ew,Y)
Y
ewma.r
medias.ew
Y
dados[1:0]
length(dados[1:0])
length(dados[1:-1])
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[1:i-1],lambda,mi0))
}
#aplica a função para cada posição
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=Y)
})
)
#verifica se produz a mesma saída
all.equal(medias.ew,Y)
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[-(i-1)],lambda,mi0))
}
#aplica a função para cada posição
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=Y)
})
)
#verifica se produz a mesma saída
all.equal(medias.ew,Y)
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[-(i-1)],lambda,mi0))
}
#aplica a função para cada posição
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=Y)
})
)
#verifica se produz a mesma saída
#all.equal(medias.ew,Y)
Y
dados[-32]
dados[-31]
medias.ew
Y
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[-i],lambda,mi0))
}
#aplica a função para cada posição
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=Y)
})
)
#verifica se produz a mesma saída
#all.equal(medias.ew,Y)
Y
dados[-(1:31)]
Y<-alvo
ewma.r<- function(x,lambda,mi0){
i<-length(x)
if(i==0) return(mi0)
return(lambda*x[i] + (1-lambda)*ewma.r(x[-i],lambda,mi0))
}
#aplica a função para cada posição
Y<-append(Y, sapply(1:length(dados),FUN=function(x){
ewma.r(x=dados[1:x], lambda=peso,mi0=Y)
})
)
#verifica se produz a mesma saída
all.equal(medias.ew,Y)
getwd()
getwd()
dados <- read.csv("Tab7.1-Costa.txt",dec=",",sep = "\n",header = F)
getwd()
## Function "calcCT1"
"calcCT1" <- function(df=fumig,
times=c(5,10,30,60,90,120),
ctcols=3:8){
multiplier <- c(7.5,12.5,25,30,30,15)
m <- dim(df)[1]
ctsum <- numeric(m)
for(i in 1:m){
y <- unlist(df[i, ctcols])
ctsum[i] <- sum(multiplier*y)/60
}
df <- cbind(ctsum=ctsum, df[,-ctcols])
df
}
## Function "calcCT1"
"calcCT1" <- function(df=fumig,
times=c(5,10,30,60,90,120),
ctcols=3:8){
multiplier <- c(7.5,12.5,25,30,30,15)
m <- dim(df)[1]
ctsum <- numeric(m)
for(i in 1:m){
y <- unlist(df[i, ctcols])
ctsum[i] <- sum(multiplier*y)/60
}
df <- cbind(ctsum=ctsum, df[,-ctcols])
df
}
##
## Function "calcCT2"
"calcCT2" <- function(df=fumig,
times=c(5,10,30,60,90,120),
ctcols=3:8){
multiplier <- c(7.5,12.5,25,30,30,15)
mat <- as.matrix(df[, ctcols])
ctsum <- mat%*%multiplier/60
cbind(ctsum=ctsum, df[,-ctcols])
}
##
## Function "calcCT3"
"calcCT3" <- function(df=fumig,
times=c(5,10,30,60,90,120),
ctcols=3:8){
multiplier <- c(7.5,12.5,25,30,30,15)
mat <- as.matrix(df[, ctcols])
ctsum <- apply(mat, 1,
FUN=function(x) sum(x*multiplier))/60
cbind(ctsum=ctsum, df[,-ctcols])
}
##
#Verificando se todas as funções retornam o mesmo resultado
calcCT1()
data(fumig,package="DAAGxtras")
install.packages("DAAGxtras")
data(fumig,package="DAAG")
install.packages("DAAG")
data(fumig,package="DAAG")
install.packages('DAAGxtras')
boxplot(Sepal.Length,data=iris)
boxplot(Sepal.Length ~,data=iris)
boxplot(~ Sepal.Length ,data=iris)
boxplot(. ~ Sepal.Length ,data=iris)
plot(. ~ Species,iris)
plot(Sepal.Width ~ Species,iris)
library(shiny)
library(shinyMobile)
runApp('D:/Documentos (D)/Shiny/teste2')
runApp('D:/Documentos (D)/Shiny/teste2')
runApp('D:/Documentos (D)/Shiny/teste2')
runApp('D:/Documentos (D)/Shiny/teste2')
runApp('D:/Documentos (D)/Shiny/teste2')
dia.semana<- function(dia=as.numeric(substr(Sys.Date(),9,10)),
mes=as.numeric(substr(Sys.Date(),6,7)),
ano=as.numeric(substr(Sys.Date(),1,4))){
#vetor com todos os nomes dos dias da semana
diasSemana<- c("Domingo",paste0(c('Segunda','Terça','Quarta','Quinta','Sexta'),"-feira"),
"Sábado")
#verifica quais sao janeiro ou fevereiro
janfev <- mes<3
#define ano no seculo Y
Y<-ano%%100
Y[which(janfev)] <- (Y[which(janfev)] - 1)
#define o número do século C
C<-floor(ano/100)
#define dia do mes K
K<- dia
#define o número do mês M
M<- numeric(length(mes))
M[which(janfev)] <- mes[which(janfev)]+10
M[which(!janfev)] <- mes[which(!janfev)]-2
#calcula a congruencia de Zeller
f<-(floor(2.6*M-0.2)+K+Y+floor(Y/4)+floor(C/4)-2*C)%%7
f[which(f==0)] <- 7
return(diasSemana[f])
}
#ESSA FUNÇÃO NÃO FUNCIONOU PARA AS DATAS TESTADAS:
# 1:31/3:10/2014
# 1:31/c(1:4,8,9,11)/2000
dia.semana()
dia.semana<- function(dia=as.numeric(substr(Sys.Date(),9,10)),
mes=as.numeric(substr(Sys.Date(),6,7)),
ano=as.numeric(substr(Sys.Date(),1,4))){
#vetor com todos os nomes dos dias da semana
diasSemana<- c("Domingo",paste0(c('Segunda','Terça','Quarta','Quinta','Sexta'),"-feira"),
"Sábado")
#verifica quais sao janeiro ou fevereiro
janfev <- mes<3
#define ano no seculo Y
Y<-ano%%100
Y[which(janfev)] <- (Y[which(janfev)] - 1)
#define o número do século C
C<-floor(ano/100)
#define dia do mes K
K<- dia
#define o número do mês M
M<- numeric(length(mes))
M[which(janfev)] <- mes[which(janfev)]+10
M[which(!janfev)] <- mes[which(!janfev)]-2
#calcula a congruencia de Zeller
f<-(floor(2.6*M-0.2)+K+Y+floor(Y/4)+floor(C/4)-2*C)%%7
return(diasSemana[f+1])
}
#ESSA FUNÇÃO NÃO FUNCIONOU PARA AS DATAS TESTADAS:
# 1:31/3:10/2014
# 1:31/c(1:4,8,9,11)/2000
dia.semana()
dia.semana(1,1,2000)
dia.semana(1,5,2014)
dia.semana()
dia.semana<- function(dia=as.numeric(substr(Sys.Date(),9,10)),
mes=as.numeric(substr(Sys.Date(),6,7)),
ano=as.numeric(substr(Sys.Date(),1,4))){
#vetor com todos os nomes dos dias da semana
diasSemana<- c("Domingo",paste0(c('Segunda','Terça','Quarta','Quinta','Sexta'),"-feira"),
"Sábado")
#verifica quais sao janeiro ou fevereiro
janfev <- mes<3
#define ano no seculo Y
Y<-ano%%100
Y[which(janfev)] <- (Y[which(janfev)] - 1)
#define o número do século C
C<-floor(ano/100)
#define dia do mes K
K<- dia
#define o número do mês M
M<- numeric(length(mes))
M[which(janfev)] <- mes[which(janfev)]+10
M[which(!janfev)] <- mes[which(!janfev)]-2
#calcula a congruencia de Zeller
f<-(floor(2.6*M-0.2)+K+Y+floor(Y/4)+floor(C/4)-2*C)%%7
#retorna o nome do dia da semana correspondente ao valor de f
return(diasSemana[f+1])
}
#ESSA FUNÇÃO NÃO FUNCIONOU PARA AS DATAS TESTADAS:
# 1:31/3:10/2014
# 1:31/c(1:4,8,9,11)/2000
dia.semana(5,6,2015)
dia.semana<- function(dia=as.numeric(substr(Sys.Date(),9,10)),
mes=as.numeric(substr(Sys.Date(),6,7)),
ano=as.numeric(substr(Sys.Date(),1,4))){
#vetor com todos os nomes dos dias da semana
diasSemana<- c("Domingo",paste0(c('Segunda','Terça','Quarta','Quinta','Sexta'),"-feira"),
"Sábado")
#verifica quais sao janeiro ou fevereiro
janfev <- mes<3
#define ano no seculo Y
Y<-ano%%100
Y[which(janfev)] <- (Y[which(janfev)] - 1)
#define o número do século C
C<-floor(ano/100)
#define dia do mes K
K<- dia
#define o número do mês M
M<- numeric(length(mes))
M[which(janfev)] <- mes[which(janfev)]+10
M[which(!janfev)] <- mes[which(!janfev)]-2
#calcula a congruencia de Zeller
f<-(floor(2.6*M-0.2)+K+Y+floor(Y/4)+floor(C/4)-2*C)%%7
#retorna o nome do dia da semana correspondente ao valor de f
return(diasSemana[f+1])
}
dia.semana(c(23,24,5),c(3,2,5),c(1966,1969,2019))
28
28-8
28%%10
trunc(28/10)*10
x<-5:40
any(x==0:9)
any(x)==0:9
x==0:9
f1<-function(x){
alg <- any(x==0)
}
any(x==0,x==1)
any(x==0,x==6)
shiny::runApp('D:/Documentos (D)/UFJF/6-PERIODO/EST. COMPUTACIONAL I/TRABALHO A/dashboard')
setwd("D:/Documentos (D)/UFJF/6-PERIODO/EST. COMPUTACIONAL I/TRABALHO A/dashboard")
runApp()
a<-t.dados|> ggplot(aes(x=numMes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F,size=.8) +
scale_x_continuous(breaks=1:12,labels=meses,expand = c(0,0))+
scale_y_continuous(limits = c(-2, 2.7),expand = c(0,0)) +
coord_radial(start=pi/6) +
scale_color_distiller(palette="RdYlBu") +
geom_hline(yintercept = c(2,1.5), color="white")+
annotate("segment", x = c(11.7,11.7), xend = c(12.3,12.3), y=c(1.5,2), yend =c(1.5,2),colour = "grey5",size=2) +
annotate("text",x=12,y=c(1.5,2),label=c("1.5°C","2°C"),color="white")+
geom_label(aes(x = 12, y=-2, label = Ano),label.size=0, label.padding=unit(10,"pt"),
size=6,color="white",fill="grey5")+
theme(
panel.background = element_rect(fill="grey5", size=1),
plot.background = element_rect(fill = "grey50",color="grey50"),
panel.grid = element_blank(),
axis.ticks = element_blank(),
axis.text.x = element_text(color="white",size=20),
axis.text.y = element_blank(),
axis.title.x= element_blank(),
axis.title.y = element_blank()
)+
transition_manual(frames = Ano, cumulative = T)
anim_save("espiral.gif",animation=animate(bleb,height = 5, width = 5, units = "in", res = 250))
bleb<-t.dados|> ggplot(aes(x=numMes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F,size=.8) +
scale_x_continuous(breaks=1:12,labels=meses,expand = c(0,0))+
scale_y_continuous(limits = c(-2, 2.7),expand = c(0,0)) +
coord_radial(start=pi/6) +
scale_color_distiller(palette="RdYlBu") +
geom_hline(yintercept = c(2,1.5), color="white")+
annotate("segment", x = c(11.7,11.7), xend = c(12.3,12.3), y=c(1.5,2), yend =c(1.5,2),colour = "grey5",size=2) +
annotate("text",x=12,y=c(1.5,2),label=c("1.5°C","2°C"),color="white")+
geom_label(aes(x = 12, y=-2, label = Ano),label.size=0, label.padding=unit(10,"pt"),
size=6,color="white",fill="grey5")+
theme(
panel.background = element_rect(fill="grey5", size=1),
plot.background = element_rect(fill = "grey50",color="grey50"),
panel.grid = element_blank(),
axis.ticks = element_blank(),
axis.text.x = element_text(color="white",size=20),
axis.text.y = element_blank(),
axis.title.x= element_blank(),
axis.title.y = element_blank()
)+
transition_manual(frames = Ano, cumulative = T)
##LENDO E ORGANIZANDO OS DADOS
#GLB.Ts+dSST.csv foi baixado na URL abaixo
#
raws <- read.csv("GLB.Ts+dSST.csv", na="***",skip=1) |>
subset(select=1:13)
setwd("D:/Documentos (D)/UFJF/6-PERIODO/EST. COMPUTACIONAL I/TRABALHO A")
##LENDO E ORGANIZANDO OS DADOS
#GLB.Ts+dSST.csv foi baixado na URL abaixo
#
raws <- read.csv("GLB.Ts+dSST.csv", na="***",skip=1) |>
subset(select=1:13)
#vamos usar os nomes dos meses em português
meses<-c("Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago",
"Set","Out","Nov","Dez")
#para poder criar o grafico precisamos agrupar por ano e categorizar por mes:
temps<- data.frame(Ano=rep(raws$Year, times=12),
Mes=rep(meses, each=146),
temp=unlist(raws[-1]))
rownames(temps) <- NULL
#começaremos criando um grafico estático
library(gganimate)
#### V1 ####
temps|> ggplot(aes(x=Mes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F) +
coord_radial()
#temos alguns problemas com essa versao inicial:
# 1. os meses estao desorganizados (ordem alfabetica, que nao é o certo)
# 2. a posicao dos meses deve começar no meio-dia
# 3. as linhas nao se conectam
#PROBLEMA 1:
#para resolver isso teremos que organizar os meses na ordem certa
#um método seria transformar a variavel Mes em FATOR:
temps$Mes<- factor(temps$Mes, levels=meses)
str(temps$Mes)
#repetindo o mesmo codigo
ggplot(temps, aes(x=Mes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F) +
coord_radial()
#resolvido!
#PROBLEMA 2:
#Para resolver isso é só usar um argumento de coord_radial(start)
ggplot(temps,aes(x=Mes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F) +
coord_radial(start=pi/6)
#ta meio ruim de ler porque ficou sobreposto, depois mexemos nisso
#PROBLEMA 3:
# aqui vai precisar de uma gambiarra; porque queremos que o valor de dezembro
#conecte com o janeiro do próximo ano, para que seja uma linha contínua
proxJan <- filter(temps,Mes == "Jan")
#PROBLEMA 3:
# aqui vai precisar de uma gambiarra; porque queremos que o valor de dezembro
#conecte com o janeiro do próximo ano, para que seja uma linha contínua
proxJan <- filter(temps,Mes == "Jan")
View(temps)
##LENDO E ORGANIZANDO OS DADOS
#GLB.Ts+dSST.csv foi baixado na URL abaixo
#
raws <- read.csv("GLB.Ts+dSST.csv", na="***",skip=1) |>
subset(select=1:13)
#vamos usar os nomes dos meses em português
meses<-c("Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago",
"Set","Out","Nov","Dez")
#para poder criar o grafico precisamos agrupar por ano e categorizar por mes:
temps<- data.frame(Ano=rep(raws$Year, times=12),
Mes=rep(meses, each=146),
temp=unlist(raws[-1]))
rownames(temps) <- NULL
#começaremos criando um grafico estático
library(gganimate)
#### V1 ####
temps|> ggplot(aes(x=Mes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F) +
coord_radial()
#temos alguns problemas com essa versao inicial:
# 1. os meses estao desorganizados (ordem alfabetica, que nao é o certo)
# 2. a posicao dos meses deve começar no meio-dia
# 3. as linhas nao se conectam
#PROBLEMA 1:
#para resolver isso teremos que organizar os meses na ordem certa
#um método seria transformar a variavel Mes em FATOR:
temps$Mes<- factor(temps$Mes, levels=meses)
str(temps$Mes)
#repetindo o mesmo codigo
ggplot(temps, aes(x=Mes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F) +
coord_radial()
#resolvido!
#PROBLEMA 2:
#Para resolver isso é só usar um argumento de coord_radial(start)
ggplot(temps,aes(x=Mes,y=temp,group=Ano,color=Ano)) +
geom_line(show.legend = F) +
coord_radial(start=pi/6)
#ta meio ruim de ler porque ficou sobreposto, depois mexemos nisso
#PROBLEMA 3:
# aqui vai precisar de uma gambiarra; porque queremos que o valor de dezembro
#conecte com o janeiro do próximo ano, para que seja uma linha contínua
proxJan <- filter(temps,Mes == "Jan")
